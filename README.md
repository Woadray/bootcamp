# COURSES
## [Berkeley - CS 61A: Structure and Interpretation of Computer Programs](https://inst.eecs.berkeley.edu/~cs61a/sp21/)<br>

      [ ] Lecture 01 - Introduction
      [ ] Lecture 02 - Functions
      [ ] Lecture 03 - Control
      [ ] Lecture 04 - Higher Order Functions    
      [ ] Lecture 05 - Environments    
      [ ] Lecture 06 - Recursion    
      [ ] Lecture 07 - Tree Recursion    
      [ ] Lecture 08 - More on Functions    
      [ ] Lecture 09 - Function Examples    
      [ ] Lecture 10 - Containers    
      [ ] Lecture 11 - Data Abstraction    
      [ ] Lecture 12 - Dictionaries, Matrices, and Trees    
      [ ] Lecture 13 - Creating Trees, Mutability, List Mutations    
      [ ] Lecture 14 - List Mutations, Identity vs. Equality, Global Nonlocal    
      [ ] Lecture 15 - Iterators + Generators    
      [ ] Lecture 16 - Objects + Classes    
      [ ] Lecture 17 - Inheritance + Composition    
      [ ] Lecture 18 - Special Object Methods    
      [ ] Lecture 19 - Recursive Objects (LinkedList + Tree)    
      [ ] Lecture 20 - Complexity    
      [ ] Lecture 21 - Memoization    
      [ ] Lecture 22 - Generics    
      [ ] Lecture 23 - Fun with Iterables    
      [ ] Lecture 24 - Scheme    
      [ ] Lecture 25 - Scheme Examples    
      [ ] Lecture 26 - Calculator    
      [ ] Lecture 27 - Interpreters    
      [ ] Lecture 28 - Undecidability    
      [ ] Lecture 29 - Macros    
      [ ] Lecture 30 - Declarative Programming    
      [ ] Lecture 31 - Regular Expressions    
      [ ] Lecture 32 - BNF    
      [ ] Lecture 33 - Review Regular Expressions + BNF    
      [ ] Lecture 34 - Review Scheme    
      [ ] Lecture 35 - Intro to SQL    
      [ ] Lecture 36 - Review Linked Lists + Trees    
      [ ] Lecture 37 - OOP Review + Design    
      [ ] Lecture 38 - Conclusion

## [Berkeley - CS 61B: Data Structures](https://sp21.datastructur.es/)<br>

      [ ] Lecture 01 - Introduction                 
      [ ] Lecture 02 - Defining and Using Classes
      [ ] Lecture 03 - Testing
      [ ] Lecture 04 - References, Recursion, and Lists
      [ ] Lecture 05 - SLLists, Nested Classes, Sentinel Nodes
      [ ] Lecture 06 - DLLists, Arrays
      [ ] Lecture 07 - ALists, Resizing, vs. SLists
      [ ] Lecture 08 - Inheritance, Implements
      [ ] Lecture 09 - Extends, Casting, Higher Order Functions
      [ ] Lecture 10 - Subtype Polymorphism vs. HoFs
      [ ] Lecture 11 - Exceptions, Iterators, Object Methods
      [ ] Lecture 12 - Command Line Programming, Git, Project 2 Preview
      [ ] Lecture 13 - Asymptotics 1
      [ ] Lecture 14 - Disjoint Sets
      [ ] Lecture 15 - Asymptotics 2
      [ ] Lecture 16 - ADTs, Sets, Maps, Binary Search Trees
      [ ] Lecture 17 - B-Trees
      [ ] Lecture 18 - Red Black Trees
      [ ] Lecture 19 - Hashing
      [ ] Lecture 20 - Heaps and PQs
      [ ] Lecture 21 - Tree and Graph Traversals
      [ ] Lecture 22 - Graph Traversals and Implementations
      [ ] Lecture 23 - Shortest Paths
      [ ] Lecture 24 - Minimum Spanning Trees
      [ ] Lecture 25 - Range Searching and Multi-Dimensional Data
      [ ] Lecture 26 - Prefix Operations and Tries
      [ ] Lecture 27 - Software Engineering I
      [ ] Lecture 28 - Reductions and Decomposition
      [ ] Lecture 29 - Basic Sorts
      [ ] Lecture 30 - Quick Sort
      [ ] Lecture 31 - Software Engineering II
      [ ] Lecture 32 - More Quick Sort, Sorting Summary
      [ ] Lecture 33 - Software Engineering III
      [ ] Lecture 34 - Sorting and Algorithmic Bounds
      [ ] Lecture 35 - Radix Sorts
      [ ] Lecture 36 - Sorting and Data Structures Conclusion
      [ ] Lecture 37 - Software Engineering IV
      [ ] Lecture 38 - Compression
      [ ] Lecture 39 - Compression, Complexity, and P=NP
      [ ] Lecture 40 - Summary, Fun

## [Berkeley CS61C: Great Ideas in Computer Architecture (Machine Structures)](https://cs61c.org/sp22/)<br>

      [ ] Lecture 01 - Introduction
      [ ] Lecture 02 - Number Representation    
      [ ] Lecture 03 - C Introduction - Basics    
      [ ] Lecture 04 - C Introduction - Pointers, Array, Strings    
      [ ] Lecture 05 - C Memory Management    
      [ ] Lecture 06 - Floating Point    
      [ ] Lecture 07 - RISC-V - Introduction    
      [ ] Lecture 08 - RISC-V - Decisions I    
      [ ] Lecture 09 - RISC-V - Decisions II    
      [ ] Lecture 10 - RISC-V - Procedures    
      [ ] Lecture 11 - RISC-V - Instruction Format I    
      [ ] Lecture 12 - RISC-V - Intruction Format II    
      [ ] Lecture 13 - Compilation, Assembly, Linking, Loading    
      [ ] Lecture 14 - Introduction to Synchronous Digital Systems    
      [ ] Lecture 15 - State, State Machines    
      [ ] Lecture 16 - Combinational Logic I    
      [ ] Lecture 17 - Combinational Logic II    
      [ ] Lecture 18 - Single-Cycle CPU Datapath I    
      [ ] Lecture 19 - Signle-Cycle CPU Datapath II    
      [ ] Lecture 20 - Single-Cycle CPU Datapath III    
      [ ] Lecture 21 - Pipelining I    
      [ ] Lecture 22 - Pipelining II    
      [ ] Lecture 23 - Pipelining III    
      [ ] Lecture 24 - Caches I    
      [ ] Lecture 25 - Caches II    
      [ ] Lecture 26 - Caches III    
      [ ] Lecture 27 - Caches IV    
      [ ] Lecture 28 - OS & Virtual Memory    
      [ ] Lecture 29 - Virtual Memory I    
      [ ] Lecture 30 - Virtual Memory II    
      [ ] Lecture 31 - I_O    
      [ ] Lecture 32 - Flynn Taxonomy, SIMD Instructions    
      [ ] Lecture 33 - Thread-Level Parallelism I    
      [ ] Lecture 34 - Thread-Level Parallelism II

## [Berkeley - CS186: Introduction to Database Systems](https://cs186berkeley.net/)

      [ ] Lecture 01 - Why Study Databases
      [ ] Lecture 02 - SQL I      
      [ ] Lecture 03 - SQL II     
      [ ] Lecture 04 - Disks, Files and Buffers I    
      [ ] Lecture 05 - Disks, Files and Buffers II    
      [ ] Lecture 06 - B+ Trees    
      [ ] Lecture 07 - Refinements on Indices and B+ Trees    
      [ ] Lecture 08 - Buffer Management    
      [ ] Lecture 09 - Sorting and Hashing    
      [ ] Lecture 10 - Relational Algebra    
      [ ] Lecture 11 - Iterators and Joins    
      [ ] Lecture 12 - Parallel Query Processing    
      [ ] Lecture 13 - Query Optimization I - Plan Space    
      [ ] Lecture 14 - Query Optimization II - Costs and Search    
      [ ] Lecture 15 - Unstructured Data - Searching Text    
      [ ] Lecture 16 - DB Design - Entity-Relationship Models    
      [ ] Lecture 17 - DB Design - FDs and Normalization    
      [ ] Lecture 18 - Transactions and Concurrency I    
      [ ] Lecture 19 - Transactions and Concurrency II    
      [ ] Lecture 20 - Recovery    
      [ ] Lecture 21 - Web Crawlers and IR, Parallel Search and Ranking    
      [ ] Lecture 22 - Distributed Transactions    
      [ ] Lecture 23 - NoSQL      
      [ ] Lecture 24 - MapReduce and Spark

## [University of Helsinki - Full Stack Oppen 2022](https://fullstackopen.com/en/)<br>

      [ ] Part 00 - Fundamentals of Web apps
      [ ] Part 01 - Introduction to React
      [ ] Part 02 - Communicating with server
      [ ] Part 03 - Programming a server with NodeJS and Express
      [ ] Part 04 - Testing Express servers, user administration
      [ ] Part 05 - Testing React apps
      [ ] Part 06 - State management with Redux
      [ ] Part 07 - React router, custom hooks, styling app with CSS and webpack
      [ ] Part 08 - GraphQL
      [ ] Part 09 - TypeScript
      [ ] Part 10 - React Native
      [ ] Part 11 - CI/CD
      [ ] Part 12 - Containers
      [ ] Part 13 - Using relational databases

## [MIT - 6.031: Software Construction](http://web.mit.edu/6.031/www/sp22/)

      [ ] Chapter 01 - Static Checking
      [ ] Chapter 02 - Basic TypeScript
      [ ] Chapter 03 - Testing
      [ ] Chapter 04 - Code Review
      [ ] Chapter 05 - Version Control
      [ ] Chapter 06 - Specifications
      [ ] Chapter 07 - Designing Specifications
      [ ] Chapter 08 - Mutability & Immutability
      [ ] Chapter 09 - Avoiding Debugging
      [ ] Chapter 10 - Abstract Data Types
      [ ] Chapter 11 - Abstraction Functions & Rep Invariants
      [ ] Chapter 12 - Interfaces, Generics, & Enums
      [ ] Chapter 13 - Debugging
      [ ] Chapter 14 - Recursion
      [ ] Chapter 15 - Equality
      [ ] Chapter 16 - Map, Filter, Reduce
      [ ] Chapter 17 - Recursive Data Types
      [ ] Chapter 18 - Regular Expressions & Grammars
      [ ] Chapter 19 - Parsers
      [ ] Chapter 20 - Callbacks & Graphical User Interfaces
      [ ] Chapter 21 - Concurrency
      [ ] Chapter 22 - Promises
      [ ] Chapter 23 - Mutual Exclusion
      [ ] Chapter 24 - Message Passing
      [ ] Chapter 25 - Networking
      [ ] Chapter 26 - Little Languages I
      [ ] Chapter 27 - Little Languages II
      [ ] Chapter 28 - Ethical Software Engineering
      [ ] Chapter 29 - Team Version Control

## [Berkeley - Data 8 - Foundations of Data Science](http://data8.org/fa21/)<br>

      [ ] Lecture 01 - Introduction
      [ ] Lecture 02 - Cause and Effect 
      [ ] Lecture 03 - Tables
      [ ] Lecture 04 - Data Types
      [ ] Lecture 05 - Building Tables
      [ ] Lecture 06 - Census
      [ ] Lecture 07 - Charts
      [ ] Lecture 08 - Histograms
      [ ] Lecture 09 - Functions
      [ ] Lecture 10 - Groups
      [ ] Lecture 11 - Groups and Pivots
      [ ] Lecture 12 - Joins and Table Examples
      [ ] Lecture 13 - Iteration
      [ ] Lecture 14 - Chance and Sampling
      [ ] Lecture 14 - Simulations
      [ ] Lecture 15 - Sampling
      [ ] Lecture 17 - Assessing Models
      [ ] Lecture 18 - Decisions and Uncertainty
      [ ] Lecture 20 - Causality
      [ ] Lecture 21 - Examples
      [ ] Lecture 22 - Midterm Review
      [ ] Lecture 23 - Bootstrap
      [ ] Lecture 24 - Confidence Intervals
      [ ] Lecture 25 - Center and Spread
      [ ] Lecture 26 - The Normal Distribution
      [ ] Lecture 27 - Sample Means
      [ ] Lecture 28 - Designing Experiments
      [ ] Lecture 29 - Correlation
      [ ] Lecture 29 - Decisions and Uncertainty
      [ ] Lecture 30 - Linear Regression
      [ ] Lecture 31 - Least Squares
      [ ] Lecture 32 - Residuals
      [ ] Lecture 33 - Regression Inference
      [ ] Lecture 34 - Privacy
      [ ] Lecture 35 - Classification
      [ ] Lecture 36 - Classifiers
      [ ] Lecture 36 - Classifiers
      [ ] Lecture 37 - Classifiers II
      [ ] Lecture 38 - Updating Probabilities
      [ ] Lecture 39 - Case Studies
      [ ] Lecture 40 - Algorithmic Bias
      [ ] Lecture 41 - Conclusion

## [Berkeley - Data 100: Principles and Techniques of Data Science](https://ds100.org/fa21/)<br>

      [ ] Lecture 01 - Introduction
      [ ] Lecture 02 - Data Sampling and Probability I    
      [ ] Lecture 03 - Data Sampling and Probability II    
      [ ] Lecture 04 - Pandas I    
      [ ] Lecture 05 - Pandas II    
      [ ] Lecture 06 - Data Cleaning and EDA    
      [ ] Lecture 07 - Regex    
      [ ] Lecture 08 - SQL I    
      [ ] Lecture 09 - SQL II    
      [ ] Lecture 10 - Visualization I    
      [ ] Lecture 11 - Visualization II    
      [ ] Lecture 12 - Modeling    
      [ ] Lecture 13 - Simple Linear Regression    
      [ ] Lecture 14 - Ordinary Least Squares    
      [ ] Lecture 15 - Modeling in Context: Fairness in Housing Appraisal    
      [ ] Lecture 16 - Feature Engineering    
      [ ] Lecture 17 - Bias and Variance    
      [ ] Lecture 18 - Regularization and Cross-Validation    
      [ ] Lecture 19 - Guest Lecture: Physical Data and the Climate    
      [ ] Lecture 20 - Gradient Descent    
      [ ] Lecture 21 - Dimensionality Reduction & PCA    
      [ ] Lecture 22 - Logistic Regression I    
      [ ] Lecture 23 - Logistic Regression II and Classification    
      [ ] Lecture 24 - Decision Trees    
      [ ] Lecture 25 - Inference for Modeling    
      [ ] Lecture 26 - Clustering    
      [ ] Lecture 27 - Guest Lecture: The Social Cost of Carbon

## [Berkeley - CS 188: Introduction to Artificial Intelligence](https://inst.eecs.berkeley.edu/~cs188/fa21/)

      [ ] Lecture 01 - Introduction
      [ ] Lecture 02 - Uninformed Search    
      [ ] Lecture 03 - UCS, A*, and Heuristics    
      [ ] Lecture 04 - Constraint Satisfaction Problems I    
      [ ] Lecture 05 - Constraint Satisfaction Problems II    
      [ ] Lecture 06 - Search with Other Agents I    
      [ ] Lecture 07 - Search with Other Agents II    
      [ ] Lecture 08 - Markov Decision Processes I    
      [ ] Lecture 09 - Markov Decision Processes II    
      [ ] Lecture 10 - Reinforcement Learning I    
      [ ] Lecture 11 - Reinforcement Learning II    
      [ ] Lecture 12 - Probability    
      [ ] Lecture 13 - Bayesian Networks: Representation    
      [ ] Lecture 14 - Bayesian Networks: Inference    
      [ ] Lecture 15 - Bayesian Networks: Independence    
      [ ] Lecture 16 - Bayesian Networks: Sampling    
      [ ] Lecture 17 - Decision Networks and VPI    
      [ ] Lecture 18 - Hidden Markov Models    
      [ ] Lecture 19 - Particle Filtering    
      [ ] Lecture 20 - Machine Learning: Naive Bayes    
      [ ] Lecture 21 - Machine Learning: Perceptrons and Logistic Regression    
      [ ] Lecture 22 - Machine Learning: Optimization    
      [ ] Lecture 23 - Machine Learning: Neural Networks    
      [ ] Lecture 24 - Advanced Applications_ Games and Robotics    
      [ ] Lecture 25 - Conclusion

# TEXTBOOKS
## [Discrete Mathematics with Applications, Metric Edition](https://www.cengage.co.uk/books/9780357114087/)

    [ ] Chapter 1: Speaking Mathematically
    
        [ ] 1.1 Variables
        [ ] 1.2 The Language of Sets
        [ ] 1.3 The Language of Relations and Functions
        [ ] 1.4 The Language of Graphs
        
    [ ] Chapter 2: The Logic of Compound Statements
    
        [ ] 2.1 Logical Form and Logical Equivalence
        [ ] 2.2 Conditional Statements
        [ ] 2.3 Valid and Invalid Arguments
        [ ] 2.4 Application: Digital Logic Circuits
        [ ] 2.5 Application: Number Systems and Circuits for Addition
        
    [ ] Chapter 3: The Logic of Quantified Statements
    
        [ ] 3.1 Predicates and Quantified Statements I
        [ ] 3.2 Predicates and Quantified Statements II
        [ ] 3.3 Statements with Multiple Quantifiers
        [ ] 3.4 Arguments with Quantified Statements
        
    [ ] Chapter 4: Elementary Number Theory and Methods of Proof
    
        [ ] 4.1 Direct Proof and Counterexample I: Introduction
        [ ] 4.2 Direct Proof and Counterexample II: Writing Advice
        [ ] 4.3 Direct Proof and Counterexample III: Rational Numbers
        [ ] 4.4 Direct Proof and Counterexample IV: Divisibility
        [ ] 4.5 Direct Proof and Counterexample V: Division into Cases and the Quotient-Remainder Theorem
        [ ] 4.6 Direct Proof and Counterexample VI: Floor and Ceiling
        [ ] 4.7 Indirect Argument: Contradiction and Contraposition
        [ ] 4.8 Indirect Argument: Two Famous Theorems
        [ ] 4.9 Application: The Handshake Theorem
        [ ] 4.10 Application: Algorithms
        
    [ ] Chapter 5: Sequences, Mathematical Induction, and Recursion
    
        [ ] 5.1 Sequences
        [ ] 5.2 Mathematical Induction I: Proving Formulas
        [ ] 5.3 Mathematical Induction II: Applications
        [ ] 5.4 Strong Mathematical Induction and the Well-Ordering Principle for the Integers
        [ ] 5.5 Application: Correctness of Algorithms
        [ ] 5.6 Defining Sequences Recursively
        [ ] 5.7 Solving Recurrence Relations by Iteration
        [ ] 5.8 Second-Order Linear Homogeneous Recurrence Relations with Constant Coefficients
        [ ] 5.9 General Recursive Definitions and Structural Induction
        
    [ ] Chapter 6: Set Theory
    
        [ ] 6.1 Set Theory: Definitions and the Element Method of Proof
        [ ] 6.2 Properties of Sets
        [ ] 6.3 Disproofs and Algebraic Proofs
        [ ] 6.4 Boolean Algebras, Russell's Paradox, and the Halting Problem
        
    [ ] Chapter 7: Properties of Functions
    
        [ ] 7.1 Functions Defined on General Sets
        [ ] 7.2 One-to-One, Onto, and Inverse Functions
        [ ] 7.3 Composition of Functions
        [ ] 7.4 Cardinality with Applications to Computability
        
    [ ] Chapter 8: Properties of Relations
    
        [ ] 8.1 Relations on Sets
        [ ] 8.2 Reflexivity, Symmetry, and Transitivity
        [ ] 8.3 Equivalence Relations
        [ ] 8.4 Modular Arithmetic with Applications to Cryptography
        [ ] 8.5 Partial Order Relations
        
    [ ] Chapter 9: Counting and Probability
    
        [ ] 9.1 Introduction to Probability
        [ ] 9.2 Possibility Trees and the Multiplication Rule
        [ ] 9.3 Counting Elements of Disjoint Sets: The Addition Rule
        [ ] 9.4 The Pigeonhole Principle
        [ ] 9.5 Counting Subsets of a Set: Combinations
        [ ] 9.6 r-Combinations with Repetition Allowed
        [ ] 9.7 Pascal's Formula and the Binomial Theorem
        [ ] 9.8 Probability Axioms and Expected Value
        [ ] 9.9 Conditional Probability, Bayes' Formula, and Independent Events
        
    [ ] Chapter 10: Theory of Graphs and Trees
    
        [ ] 10.1 Trails, Paths, and Circuits
        [ ] 10.2 Matrix Representations of Graphs
        [ ] 10.3 Isomorphisms of Graphs
        [ ] 10.4 Trees: Examples and Basic Properties
        [ ] 10.5 Rooted Trees
        [ ] 10.6 Spanning Trees and a Shortest Path Algorithm
        
    [ ] Chapter 11: Analysis of Algorithm Efficiency
    
        [ ] 11.1 Real-Valued Functions of a Real Variable and Their Graphs
        [ ] 11.2 Big-O, Big-Omega, and Big-Theta Notations
        [ ] 11.3 Application: Analysis of Algorithm Efficiency I
        [ ] 11.4 Exponential and Logarithmic Functions: Graphs and Orders
        [ ] 11.5 Application: Analysis of Algorithm Efficiency II
        
    [ ] Chapter 12: Regular Expressions and Finite-State Automata
    
        [ ] 12.1 Formal Languages and Regular Expressions
        [ ] 12.2 Finite-State Automata
        [ ] 12.3 Simplifying Finite-State Automata
